/**
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the MIT License.
 *
 * This product includes software developed at Datadog
 * (https://www.datadoghq.com/).
 *
 * Copyright 2018 Datadog, Inc.
 */

const helpCommandRegex = /help|option|action|command|menu/i;
const usageDocsURL = "https://github.com/DataDog/slack-channel-manager/wiki/Usage-Instructions";

module.exports = (shared, logger, Channel, slack, slackEvents) => {
    slackEvents.on("message", async (event) => {
        // ignore events generated by this bot's responses
        if (event.bot_id) {
            return;
        }
        if (event.message && event.message.bot_id) {
            return;
        }

        if (!(await shared.isUserAuthorized(event.user))) {
            logger.info("Unauthorized user trying to use channel manager", {
                user: event.user,
                message: event.text
            });
            return slack.bot.chat.postMessage({
                channel: event.channel,
                text: ":no_entry_sign: *Oops, looks like you're not authorized to do that.*\n" +
                "If you would like access to this app, please contact the administrators."
            }).catch(logger.error);
        }

        const message = event.text.trim().toLowerCase();
        if (helpCommandRegex.test(message)) {
            logger.info("Recognized command", {
                user: event.user,
                command: "help"
            });

            const res = await slack.user.auth.test();
            return slack.bot.chat.postMessage({
                channel: event.channel,
                text: "Here are your options. Type:\n" +
                "- :information_source: | `help`: Print this help message\n" +
                "- :scroll: | `list [keywords ...]`: List active private channels that match your query\n\n" +
                "If you would like me to start managing one of your currently *unmanaged* private channels, " +
                `simply invite <@${res.user_id}> to that channel.\n\n` +
                "You can also click on the buttons listed below.\n" +
                `For more information about usage, please see ${usageDocsURL}.`,
                mrkdwn: true,
                attachments: [{
                    text: "",
                    fallback: "You are unable to choose an option",
                    callback_id: "menu_button",
                    color: "#3AA3E3",
                    attachment_type: "default",
                    actions: [
                        {
                            name: "request_private_channel",
                            text: "Request a private channel",
                            type: "button"
                        },
                        {
                            name: "list_private_channels",
                            text: "List active private channels",
                            type: "button",
                            value: JSON.stringify({
                                offset: 0,
                                searchTerms: ""
                            })
                        }
                    ]
                }]
            }).catch(logger.error);
        } else if (message.startsWith("list")) {
            logger.info("Recognized command", {
                user: event.user,
                command: "list"
            });
            const searchTerms = message.replace("list", "").trim().replace(/ /g, "|");
            const reply = await shared.listChannels(0, searchTerms);
            reply.channel = event.channel;
            return slack.bot.chat.postMessage(reply);
        } else {
            return slack.bot.chat.postMessage({
                channel: event.channel,
                text: "Hello there, I don't recognize your command. Try typing `help` for more options.",
            });
        }
    });

    slackEvents.on("group_rename", async (event) => {
        logger.info("Private channel renamed", { channel: event.channel.id, new_name: event.channel.name });
        return Channel.findByIdAndUpdate(event.channel.id, { name: event.channel.name })
            .exec()
            .catch(logger.error);
    });

    slackEvents.on("group_archive", async (event) => {
        logger.info("Private channel archived, removing from DB", { channel: event.channel });
        return Channel.findByIdAndRemove(event.channel)
            .exec()
            .catch(logger.error);
    });
    slackEvents.on("group_deleted", async (event) => {
        logger.info("Private channel deleted, removing from DB", { channel: event.channel });
        return Channel.findByIdAndRemove(event.channel)
            .exec()
            .catch(logger.error);
    });

    slackEvents.on("group_unarchive", async (event) => {
        logger.info("Managed private channel unarchived, adding it back to DB", { channel: event.channel });
        const res = await slack.user.conversations.info({ channel: event.channel });

        try {
            await Channel.insertMany([{
                _id: event.channel,
                name: res.channel.name,
                created: res.channel.created,
                topic: res.channel.topic.value,
                purpose: res.channel.purpose.value,
                expire_days: 28,
                reminded: false
            }]);
        } catch (err) {
            logger.error(err);
            return;
        }

        return slack.user.chat.postMessage({
            channel: event.channel,
            text: "Looks like this channel has been unarchived! I'm going to start managing it again.",
        });
    });

    slackEvents.on("member_joined_channel", async (event) => {
        // Don't do anything if this the joining member and the inviter
        // are the same (this happens when the bot creates a new channel)
        if (!event.inviter) {
            return;
        }

        let res = await slack.user.auth.test();
        const role_user_id = res.user_id;

        res = await slack.bot.auth.test();
        if (event.user == res.user_id) {
            return slack.bot.chat.postMessage({
                channel: event.channel,
                text: "It looks like you want this channel to be automatically managed. " +
                `Did you mean to invite <@${role_user_id}> instead? I just post status updates` +
                "about the automatic channel management service and interact with you in the " +
                "*Apps* section of your Slack sidebar.\n" +
                "(P.S. you can kick me from this channel if you'd like, I have nothing else to do here.)"
            });
        }

        if (role_user_id != event.user) {
            return;
        }

        res = await slack.user.conversations.info({ channel: event.channel });

        try {
            await Channel.findByIdAndUpdate(event.channel, {
                name: res.channel.name,
                created: res.channel.created,
                topic: res.channel.topic.value,
                purpose: res.channel.purpose.value,
                expire_days: 28,
                reminded: false
            }, { upsert: true, setDefaultsOnInsert: true }).exec();
        } catch (err) {
            logger.error(err);
            return;
        }

        return slack.user.chat.postMessage({
            channel: event.channel,
            text: `Thanks <@${event.inviter}>, this channel will now be managed.`,
        });
    });

    slackEvents.on("member_left_channel", async (event) => {
        const res = await slack.user.auth.test();
        if (event.user != res.user_id) {
            return;
        }

        logger.info("Channel manager left or was kicked, removing from managed DB", { channel: event.channel });
        return Channel.findByIdAndRemove(event.channel)
            .exec()
            .catch(logger.error);
    });

    slackEvents.on("error", logger.error);
};
