/**
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the MIT License.
 *
 * This product includes software developed at Datadog
 * (https://www.datadoghq.com/).
 *
 * Copyright 2018 Datadog, Inc.
 */

const helpCommandRegex = /help|option|action|command|menu/i;
const usageDocsURL = "https://github.com/DataDog/slack-channel-manager/wiki/Usage-Instructions";
const ts_day = 60*60*24;

module.exports = (shared, logger, Channel, slack, slackEvents) => {
    slackEvents.on("message", async (event) => {
        // ignore events generated by this bot's responses
        if (event.bot_id) {
            return;
        }
        if (event.message && event.message.bot_id) {
            return;
        }

        const authorized = await shared.isUserAuthorized(event.user);
        if (!authorized) {
            logger.info("Unauthorized user trying to use channel manager", {
                user: event.user,
                message: event.text
            });
            return slack.bot.chat.postMessage({
                channel: event.channel,
                text: ":no_entry_sign: *Oops, looks like you're not authorized to do that.*\n" +
                "If you would like access to this app, please contact the administrators."
            }).catch(logger.error);
        }

        const message = event.text.trim().toLowerCase();
        if (helpCommandRegex.test(message)) {
            logger.info("Recognized command", {
                user: event.user,
                command: "help"
            });

            const res = await slack.user.auth.test();
            const role_user_id = res.user_id;

            const helpText =
`Here are your options. In this chat, you can type:
- :information_source: | \`help\`: Print this help message
- :scroll: | \`list [keywords ...]\`: List active private channels that match your query
- :file_folder: | \`list_archived [search term...]\`: List archived private channels that contain the search term

You also have the following slash commands available to you in any chat:
- :telephone_receiver: | \`/request-channel [@user_to_invite]\`: Request a private channel
- :stopwatch: | \`/extend-expiry [number of days]\`: Extend a private channel's expiry date
- :date: | \`/set-expiry YYYY-MM-DD\`: Set a private channel's expiry date
- :no_entry_sign: | \`/remove-user [@user_to_remove]\`: Remove a user from a private channel

If you would like me to start managing one of your currently *unmanaged* private channels, simply invite <@${role_user_id}> to that channel.

You can also click on the buttons listed below.

_For more information about usage, please see <${usageDocsURL}>._`;
            return slack.bot.chat.postMessage({
                channel: event.channel,
                text: helpText,
                mrkdwn: true,
                attachments: [{
                    text: "",
                    fallback: "You are unable to choose an option",
                    callback_id: "menu_button",
                    color: "#3AA3E3",
                    attachment_type: "default",
                    actions: [
                        {
                            name: "request_private_channel",
                            text: "Request a private channel",
                            type: "button"
                        },
                        {
                            name: "list_private_channels",
                            text: "List active private channels",
                            type: "button",
                            value: JSON.stringify({
                                offset: 0,
                                searchTerms: ""
                            })
                        },
                        {
                            name: "list_archived_private_channels",
                            text: "List archived private channels",
                            type: "button",
                            value: JSON.stringify({
                                offset: 0,
                                searchTerms: ""
                            })
                        }
                    ]
                }]
            }).catch(logger.error);
        } else if (message.startsWith("list_archived")) {
            logger.info("Recognized command", {
                user: event.user,
                command: "list_archived"
            });
            const searchTerms = message.replace("list_archived", "").trim();
            const reply = await shared.listArchivedChannels(searchTerms);
            reply.channel = event.channel;
            return slack.bot.chat.postMessage(reply);
        } else if (message.startsWith("list")) {
            logger.info("Recognized command", {
                user: event.user,
                command: "list"
            });
            const searchTerms = message.replace("list", "").trim().replace(/ /g, "|");
            const reply = await shared.listChannels(0, searchTerms);
            reply.channel = event.channel;
            return slack.bot.chat.postMessage(reply);
        } else {
            return slack.bot.chat.postMessage({
                channel: event.channel,
                text: "Hello there, I don't recognize your command. Try typing `help` for more options.",
            });
        }
    });

    slackEvents.on("group_rename", async (event) => {
        logger.info("Private channel renamed", { channel: event.channel.id, new_name: event.channel.name });
        return Channel.findByIdAndUpdate(event.channel.id, { name: event.channel.name })
            .exec()
            .catch(logger.error);
    });

    slackEvents.on("group_archive", async (event) => {
        logger.info("Private channel archived, removing from DB", { channel: event.channel });
        return Channel.findByIdAndRemove(event.channel)
            .exec()
            .catch(logger.error);
    });
    slackEvents.on("group_deleted", async (event) => {
        logger.info("Private channel deleted, removing from DB", { channel: event.channel });
        return Channel.findByIdAndRemove(event.channel)
            .exec()
            .catch(logger.error);
    });

    slackEvents.on("group_unarchive", async (event) => {
        logger.info("Managed private channel unarchived, adding it back to DB", { channel: event.channel });
        const res = await slack.user.conversations.info({ channel: event.channel });

        try {
            const ts_expiry = Math.floor(Date.now() / 1000) + (28 * ts_day);
            await Channel.findByIdAndUpdate(event.channel, {
                name: res.channel.name,
                topic: res.channel.topic.value,
                purpose: res.channel.purpose.value,
                ts_created: res.channel.created,
                ts_expiry,
                reminded: false
            }, { upsert: true, setDefaultsOnInsert: true }).exec();
        } catch (err) {
            logger.error("MongoDB error: failed to save channel", {
                channel: event.channel
            });
            logger.error(err);
            return slack.user.chat.postMessage({
                channel: event.channel,
                text: "Something went wrong, I couldn't add this channel to my " +
                "database. Please contact the administrators. ",
            });
        }

        return slack.user.chat.postMessage({
            channel: event.channel,
            text: "Looks like this channel has been unarchived! I'm going to start managing it again.",
        });
    });

    slackEvents.on("member_joined_channel", async (event) => {
        // Don't do anything if this the joining member and the inviter
        // are the same (this happens when the bot creates a new channel)
        if (!event.inviter) {
            return;
        }

        // Get the user ID of the role account used to install the Slack
        // app to the workspace
        let res = await slack.user.auth.test();
        const role_user_id = res.user_id;

        // Get the user ID of the bot user created in the app's dashboard
        res = await slack.bot.auth.test();
        const bot_user_id = res.user_id;

        // if the user joining the channel is the same as the *bot* user, then
        // the wrong user was invited to that channel (it should have been the
        // role account instead)
        if (bot_user_id == event.user) {
            return slack.bot.chat.postMessage({
                channel: event.channel,
                text: "It looks like you want this channel to be automatically managed. " +
                `Did you mean to invite <@${role_user_id}> instead? I just post status updates` +
                "about the automatic channel management service and interact with you in the " +
                "*Apps* section of your Slack sidebar.\n" +
                "(P.S. you can kick me from this channel if you'd like, I have nothing else to do here.)"
            });
        }

        // only handle the event if the user joining the channel is the role account
        if (role_user_id != event.user) {
            return;
        }

        logger.info("Channel manager was added to an unmanaged channel, adding it to DB", {
            channel: event.channel
        });

        res = await slack.user.conversations.info({ channel: event.channel });
        const ts_expiry = Math.floor(Date.now() / 1000) + (28 * ts_day);
        try {
            await Channel.findByIdAndUpdate(event.channel, {
                name: res.channel.name,
                topic: res.channel.topic.value,
                purpose: res.channel.purpose.value,
                ts_created: res.channel.created,
                ts_expiry,
                reminded: false
            }, { upsert: true, setDefaultsOnInsert: true }).exec();
        } catch (err) {
            logger.error("MongoDB error: failed to save channel", {
                channel: event.channel
            });
            logger.error(err);
            return slack.user.chat.postMessage({
                channel: event.channel,
                text: "Something went wrong, I couldn't add this channel to my " +
                "database. Please contact the administrators. ",
            });
        }

        return slack.user.chat.postMessage({
            channel: event.channel,
            text: `Thanks <@${event.inviter}>, this channel will now be managed.`,
        });
    });

    slackEvents.on("member_left_channel", async (event) => {
        const res = await slack.user.auth.test();
        const role_user_id = res.user_id;
        if (role_user_id != event.user) {
            return;
        }

        logger.info("Channel manager left or was kicked, removing from managed DB", {
            channel: event.channel
        });
        return Channel.findByIdAndRemove(event.channel)
            .exec()
            .catch(logger.error);
    });

    slackEvents.on("error", logger.error);
};
